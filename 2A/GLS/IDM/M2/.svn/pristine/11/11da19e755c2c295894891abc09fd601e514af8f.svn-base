module game2petrinet;
create OUT: petrinet from  IN: game;

-- Obtenir le jeu qui contient ce game element.
helper context game!GameElement
def: getGame(): game!Game =
	game!Game.allInstances()
		->select(p | p.GameElement->includes(self))
		->asSequence()->first();

-- Obtenir l'objet qui contient ce packobjet.
helper context game!PackObjet
def: getObjet(): game!Objet =
	game!Objet.allInstances()
		->select(p | p.PackObjet->includes(self))
		->asSequence()->first();

-- Traduire un jeu en un PetriNet de même nom
rule Game2PetriNet {
	from g: game!Game
	to pn: petrinet!PetriNet (name<- p.name)
}

-- Traduire un objet en une Place de PetriNet
rule PackObjet2PetriNet {
	from o: game!PackObjet
	to p: petrinet!Place(
		nom <- o.getObjet().name,
		nbJetons <- o.quantite,
		reseau <- o.getGame()
		)
}

-- Traduire un Lieu en une place de PetriNet 
rule Lieu2PetriNet {
	from l: game!Lieu
	to place : petrinet!Place(
		nom <- l.name,
		nbJetons <- 1,
		reseau <- l.getGame()
		)
}

-- Traduire un Chemin en une transition de PetriNet
rule Chemin2PetriNet {
	from c: game!Chemin
	to 
		tr: petrinet!Transition(
			nom <- c.name
			reseau <- c.getGame()
			),
		arc1: petrinet!Arc(
			nom <- c.lieu1.name + ' -> ' + tr.nom,
			poids <- 1,
			predecesseur <- c.lieu1,
			sucesseur <- tr,
			type <- #normal,
			reseau <- c.getGame()
			),
		arc2: petrinet!Arc(
			nom <- tr.nom + ' -> ' + c.lieu2.nom,
			poids <- 1,
			predecesseur <- tr,
			sucesseur <- c.lieu2,
			type <- #normal,
			reseau <- c.getGame()
			),
}