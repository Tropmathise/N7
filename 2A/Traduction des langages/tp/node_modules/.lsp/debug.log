Hello - from c:\Users\thoma\.vscode\extensions\jaredly.reason-vscode-1.7.13\bin.native.exe.hot.exe
Previous log location: C:\Users\thoma\AppData\Local\Temp\lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","languageId":"ocaml","version":1,"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) =\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/compilateur.ml","languageId":"ocaml","version":1,"text":"open Passe\n\n(* Définition d'un compilateur comme l'enchaînement de \nquatre passes (gestion des identifiants, typage, placement mémoire\ngénération de code). Chaque passe prend en entrée le type de\nsortie de la passe précédente.\nLa dernière passe doit renvoyer une chaîne de caractères (le code généré)\n*)\nmodule Compilateur (Ptds:Passe) \n                    (Ptype:Passe with type t1 = Ptds.t2) \n                    (Pdep:Passe with type t1 = Ptype.t2) \n                    (Pcode:Passe with type t1 = Pdep.t2 and type t2=string) : \n                    Passe with type t1 = Ptds.t1 and type t2 = string=\nstruct\n  \n  type t1 = Ptds.t1\n  type t2 = string\n\n(* analyse_semantique : ast -> string *)\n(* Réalise l'analyse sémantique de l'arbre abstrait *)\n(* en appliquant les passes les unes après les autres *)\n(* retourne : le code issu de la dernière passe *)\n  let analyser ast =\n    let tast = Ptds.analyser ast in\n    let tyast = Ptype.analyser tast in\n    let past = Pdep.analyser tyast in\n    let code = Pcode.analyser past in\n    code\nend\n\n\n(* Compilateurs intermédiaires *)\n\n\n(* Compilateur créant l'AST *)\n(*\nmodule CompilateurRat = Compilateur (PasseTdsNop) (PasseNop) (PasseNop) (PasseCodeNopNop)\n*)\n\n(* + passe de résolution des identifiants *)\nopen PasseTdsRat\nmodule CompilateurRat = Compilateur (PasseTdsRat) (PasseTypeNop) (PasseNop) (PasseCodeNopNop) \n\n(* + passe de typage *)\n(*\nopen PasseTdsRat\nopen PasseTypeRat\nmodule CompilateurRat = Compilateur (PasseTdsRat) (PasseTypeRat) (PassePlacementNop) (PasseCodeNopNop)\n*)\n\n(* + passe de placement mémoire *)\n(*\nopen PasseTdsRat\nopen PasseTypeRat\nopen PassePlacementRat\nmodule CompilateurRat = Compilateur (PasseTdsRat) (PasseTypeRat) (PassePlacementRat) (PasseCodeNop)\n*)\n\n(* + passe de génération de code -> compilateur complet *)\n(*\nopen PasseTdsRat\nopen PasseTypeRat\nopen PassePlacementRat\nopen PasseCodeRatToTam\nmodule CompilateurRat = Compilateur (PasseTdsRat) (PasseTypeRat) (PassePlacementRat) (PasseCodeRatToTam)\n*)\n\n\nopen Lexing\n\n\n(* report_error : string -> Lexing.lexbuf -> string -> unit *)\n(* Affiche un message d'erreur lorsque le fichier n'est pas conforme à la grammaire *)\n(* filename : le nom du fichier non conforme *)\n(* lexbuf : l'analyser lexical *)\n(* msg : le message d'erreur à afficher *)\nlet report_error filename lexbuf msg =\n let (b,e) = (lexeme_start_p lexbuf, lexeme_end_p lexbuf) in\n let fc = b.pos_cnum - b.pos_bol + 1 in\n let lc = e.pos_cnum - b.pos_bol + 1 in\n  Printf.eprintf \"File \\\"%s\\\", line %d, characters %d-%d: %s\\n\" filename b.pos_lnum fc lc msg\n\n\n(* compiler : string -> string *)\n(* Compilter un code rat en un code TAM *)\n(* Paramètre ratfile : le nom du fichier rat à compiler *)\n(* Utilise le compilateur \"CompilateurRat\" pour générer le code associé au fichier rat *)\n(* Erreur si soucis lors de l'analyse lexicale, l'analyse syntaxique,\n mauvaise utilisation des identifiants ou soucis de typage *)\nlet compiler ratfile =\n  let input = open_in ratfile in\n  let filebuf = Lexing.from_channel input in\n  try\n    let ast = Parser.main Lexer.token filebuf in\n    \"; \" ^ ratfile ^ \"\\n\" ^ (CompilateurRat.analyser ast)\n  with\n  | Lexer.Error _ as e ->\n      report_error ratfile filebuf \"lexical error (unexpected character).\";\n      raise e\n  | Parser.Error as e->\n      report_error ratfile filebuf \"syntax error.\";\n      raise e\n\n(* compilerVersFichier : string -> string -> () *)\n(* Compiler un code rat en un code TAM et le sauve dans un fichier *)\n(* ratfile : le nom du fichier rat à compiler *)\n(* tamfile : le nom du fichier rat où sauver le résultat *)\nlet compilerVersFichier ratfile tamfile =\n   let tamcode = compiler ratfile in\n   let chan = open_out tamfile in\n   output_string chan tamcode;\n   close_out chan\n"}}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 1, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/compilateur.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 2, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":193,"character":41},"end":{"line":193,"character":41}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 3, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 4, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/compilateur.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 5, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":3}}
Read message 
{"jsonrpc":"2.0","id":6,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":193,"character":41},"end":{"line":193,"character":41}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 6, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","id":7,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"position":{"line":180,"character":7}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 7, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","id":8,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":180,"character":7},"end":{"line":180,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 8, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":6}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":7}}
Read message 
{"jsonrpc":"2.0","id":9,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":179,"character":40},"end":{"line":179,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 9, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":8}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":9}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":2},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) = \n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":10,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 10, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":3},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) = A\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":11,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"position":{"line":179,"character":42},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 11, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":4},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) = As\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":12,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":179,"character":43},"end":{"line":179,"character":43}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 12, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":12}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":5},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) = Ast\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":13,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":179,"character":44},"end":{"line":179,"character":44}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 13, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":13}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":11}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":6},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) = Ast.\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":14,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"position":{"line":179,"character":45},"context":{"triggerKind":2,"triggerCharacter":"."}}}
[server] Got a method textDocument/completion
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 14, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","id":15,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":179,"character":45},"end":{"line":179,"character":45}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 15, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":15}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":14}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":10},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) = \n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":11},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) = a\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":16,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"position":{"line":179,"character":42},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 16, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","id":17,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":179,"character":42},"end":{"line":179,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 17, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":17}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":16}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":12},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) = \n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":13},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) = A\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":18,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"position":{"line":179,"character":42},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 18, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":14},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) = As\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":19,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":179,"character":43},"end":{"line":179,"character":43}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 19, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":19}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":18}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":17},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) =\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":20,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":179,"character":40},"end":{"line":179,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 20, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","id":21,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 21, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":22,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 22, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","id":23,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"position":{"line":45,"character":33}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 23, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","id":24,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":45,"character":33},"end":{"line":45,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 24, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":23}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":24}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":21},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) =\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":25,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":45,"character":29},"end":{"line":45,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 25, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":25}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":23},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTd\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) =\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":26,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":45,"character":27},"end":{"line":45,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 26, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":26}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":24},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) =\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":27,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"position":{"line":45,"character":28},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 27, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","id":28,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":45,"character":28},"end":{"line":45,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 28, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":28}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":27}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":25},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) =\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":29,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"position":{"line":45,"character":29},"context":{"triggerKind":2,"triggerCharacter":"."}}}
[server] Got a method textDocument/completion
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 29, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","id":30,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":45,"character":29},"end":{"line":45,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 30, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":30}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":26},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.T\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) =\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":31,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":45,"character":30},"end":{"line":45,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 31, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":31}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":27},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.Tr\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) =\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":32,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":45,"character":31},"end":{"line":45,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 1.00636482239ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 32, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","id":33,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 33, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found", "command": ""}}]}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":32}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":28},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.Tru\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) =\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":34,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":45,"character":32},"end":{"line":45,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 34, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":34}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":29},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) =\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","id":35,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"position":{"line":45,"character":33},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 35, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","id":36,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"},"range":{"start":{"line":45,"character":33},"end":{"line":45,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 36, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":29},"contentChanges":[{"text":"(* Module de la passe de gestion des identifiants *)\nmodule PasseTdsRat : Passe.Passe with type t1 = Ast.AstSyntax.programme and type t2 = Ast.AstTds.programme =\nstruct\n\n  open Tds\n  open Exceptions\n  open Ast\n  open AstTds\n\n  type t1 = Ast.AstSyntax.programme\n  type t2 = Ast.AstTds.programme\n\n\n(* analyse_tds_expression : AstSyntax.expression -> AstTds.expression *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre e : l'expression à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'expression\nen une expression de type AstTds.expression *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_expression tds e = match e with\n  | AstSyntax.AppelFonction (nom,listparam) ->\n      begin\n      match (chercherGlobalement tds nom) with\n        | Some info_ast -> begin\n                            match (info_ast_to_info info_ast) with \n                            | InfoFun _ -> let ne = (List.map (analyse_tds_expression tds) listparam) in\n                                            AstTds.AppelFonction(info_ast,ne)\n                            | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                           end\n        | None -> raise (IdentifiantNonDeclare (nom))\n      end\n  | AstSyntax.Rationnel (exp1,exp2) -> AstTds.Rationnel (analyse_tds_expression tds exp1, analyse_tds_expression tds exp2)\n  | AstSyntax.Numerateur exp ->AstTds.Numerateur (analyse_tds_expression tds exp)\n  | AstSyntax.Denominateur exp -> AstTds.Denominateur (analyse_tds_expression tds exp)\n  | AstSyntax.Ident nom ->\n    begin\n        match (chercherGlobalement tds nom) with \n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoVar _ -> AstTds.Ident info_ast\n                              | InfoConst (_,v) -> AstTds.Entier v\n                              | _ -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (nom))\n    end\n  | AstSyntax.True -> AstTds.True\n  | AstSyntax.False -> AstTds.False\n  | AstSyntax.Entier int -> AstTds.Entier int \n  | AstSyntax.Binaire (operateur,exp1,exp2) -> AstTds.Binaire(operateur,(analyse_tds_expression tds exp1),(analyse_tds_expression tds exp2))\n\n(* analyse_tds_instruction : AstSyntax.instruction -> tds -> AstTds.instruction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre i : l'instruction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme l'instruction\nen une instruction de type AstTds.instruction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet rec analyse_tds_instruction tds i =\n  match i with\n  | AstSyntax.Declaration (t, n, e) ->\n      begin\n        match chercherLocalement tds n with\n        | None ->\n            (* L'identifiant n'est pas trouvé dans la tds locale, \n            il n'a donc pas été déclaré dans le bloc courant *)\n            (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n            (* et obtention de l'expression transformée *) \n            let ne = analyse_tds_expression tds e in\n            (* Création de l'information associée à l'identfiant *)\n            let info = InfoVar (n,Undefined, 0, \"\") in\n            (* Création du pointeur sur l'information *)\n            let ia = info_to_info_ast info in\n            (* Ajout de l'information (pointeur) dans la tds *)\n            ajouter tds n ia;\n            (* Renvoie de la nouvelle déclaration où le nom a été remplacé par l'information \n            et l'expression remplacée par l'expression issue de l'analyse *)\n            Declaration (t, ne, ia) \n        | Some _ ->\n            (* L'identifiant est trouvé dans la tds locale, \n            il a donc déjà été déclaré dans le bloc courant *) \n            raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affectation (n,e) ->\n      begin\n        match chercherGlobalement tds n with\n        | None -> \n          (* L'identifiant n'est pas trouvé dans la tds globale. *) \n          raise (IdentifiantNonDeclare n)\n        | Some info -> \n          (* L'identifiant est trouvé dans la tds globale, \n          il a donc déjà été déclaré. L'information associée est récupérée. *) \n          begin\n            match info_ast_to_info info with\n            | InfoVar _ -> \n              (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n              (* et obtention de l'expression transformée *) \n              let ne = analyse_tds_expression tds e in\n              (* Renvoie de la nouvelle affectation où le nom a été remplacé par l'information \n              et l'expression remplacée par l'expression issue de l'analyse *)\n               Affectation (ne, info)\n            |  _ ->\n              (* Modification d'une constante ou d'une fonction *)  \n              raise (MauvaiseUtilisationIdentifiant n) \n          end\n      end\n  | AstSyntax.Constante (n,v) -> \n      begin\n        match chercherLocalement tds n with\n        | None -> \n        (* L'identifiant n'est pas trouvé dans la tds locale, \n        il n'a donc pas été déclaré dans le bloc courant *)\n        (* Ajout dans la tds de la constante *)\n        ajouter tds n (info_to_info_ast (InfoConst (n,v))); \n        (* Suppression du noeud de déclaration des constantes devenu inutile *)\n        Empty\n        | Some _ ->\n          (* L'identifiant est trouvé dans la tds locale, \n          il a donc déjà été déclaré dans le bloc courant *) \n          raise (DoubleDeclaration n)\n      end\n  | AstSyntax.Affichage e -> \n      (* Vérification de la bonne utilisation des identifiants dans l'expression *)\n      (* et obtention de l'expression transformée *)\n      let ne = analyse_tds_expression tds e in\n      (* Renvoie du nouvel affichage où l'expression remplacée par l'expression issue de l'analyse *)\n      Affichage (ne)\n  | AstSyntax.Conditionnelle (c,t,e) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc then *)\n      let tast = analyse_tds_bloc tds t in\n      (* Analyse du bloc else *)\n      let east = analyse_tds_bloc tds e in\n      (* Renvoie la nouvelle structure de la conditionnelle *)\n      Conditionnelle (nc, tast, east)\n  | AstSyntax.TantQue (c,b) -> \n      (* Analyse de la condition *)\n      let nc = analyse_tds_expression tds c in\n      (* Analyse du bloc *)\n      let bast = analyse_tds_bloc tds b in\n      (* Renvoie la nouvelle structure de la boucle *)\n      TantQue (nc, bast)\n\n      \n(* analyse_tds_bloc : AstSyntax.bloc -> AstTds.bloc *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre li : liste d'instructions à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le bloc\nen un bloc de type AstTds.bloc *)\n(* Erreur si mauvaise utilisation des identifiants *)\nand analyse_tds_bloc tds li =\n  (* Entrée dans un nouveau bloc, donc création d'une nouvelle tds locale \n  pointant sur la table du bloc parent *)\n  let tdsbloc = creerTDSFille tds in\n  (* Analyse des instructions du bloc avec la tds du nouveau bloc \n  Cette tds est modifiée par effet de bord *)\n   let nli = List.map (analyse_tds_instruction tdsbloc) li in\n   (* afficher_locale tdsbloc ; *) (* décommenter pour afficher la table locale *)\n   nli\n\n\n(* analyse_tds_fonction : AstSyntax.fonction -> AstTds.fonction *)\n(* Paramètre tds : la table des symboles courante *)\n(* Paramètre : la fonction à analyser *)\n(* Vérifie la bonne utilisation des identifiants et transforme la fonction\nen une fonction de type AstTds.fonction *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyse_tds_fonction maintds (AstSyntax.Fonction(t,n,lp,li,e))  =\n  let tds_info_ast =\n  begin\n    match (chercherGlobalement maintds n) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> info_ast\n                              | InfoVar (nom,_,_,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                              | InfoConst (nom,_) -> raise (MauvaiseUtilisationIdentifiant (nom));\n                            end\n          | None -> raise (IdentifiantNonDeclare (n)) (*Problème *)\n  end\n  in\n  let analyse_tds_varconst tds (t,nom) =\n  begin\n   match (chercherGlobalement tds nom) with\n          | Some info_ast -> begin\n                              match (info_ast_to_info info_ast) with \n                              | InfoFun _ -> raise (MauvaiseUtilisationIdentifiant (nom))\n                              | _ -> (t,info_ast)\n                            end\n          | None -> raise (IdentifiantNonDeclare (n))\n  end\n  in\n  AstTds.Fonction(t,tds_info_ast,List.map (analyse_tds_varconst maintds) lp, List.map (analyse_tds_instruction maintds) li, analyse_tds_expression maintds e)\n\n(* analyser : AstSyntax.ast -> AstTds.ast *)\n(* Paramètre : le programme à analyser *)\n(* Vérifie la bonne utilisation des identifiants et tranforme le programme\nen un programme de type AstTds.ast *)\n(* Erreur si mauvaise utilisation des identifiants *)\nlet analyser (AstSyntax.Programme (fonctions,prog)) =\n  let tds = creerTDSMere () in\n  let nf = List.map (analyse_tds_fonction tds) fonctions in\n  let nb = analyse_tds_bloc tds prog in\n  Programme (nf,nb)\n\nend\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml","version":29}}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Read message 
{"jsonrpc":"2.0","id":37,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 37, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":38,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/passeTdsRat.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 38, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":38}}
Read message 
{"jsonrpc":"2.0","method":"$/setTraceNotification","params":{"value":"off"}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","id":39,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/compilateur.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 39, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found"}}
Read message 
{"jsonrpc":"2.0","id":40,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///c%3A/Users/thoma/OneDrive/Desktop/N7/2A/Traduction%20des%20langages/tp/sourceEtu/compilateur.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.ms
Found a `dune` file at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
]] Making a new jbuilder package at c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
=== Project root: c:\Users\thoma\OneDrive\Desktop\N7\2A\Traduction des langages\tp\sourceEtu
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
Sending response {"id": 40, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Invalid response for opam config var sys-ocaml-version\n\n[ERROR] Variable sys-ocaml-version not found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":41,"method":"shutdown","params":null}
Sending response {"id": 41, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"exit","params":null}
Got exit! Terminating loop
Finished
